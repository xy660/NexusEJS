declare global {
  interface NexusBuffer {
    /**读取指定大小无符号整数 */
    readUInt(offset: number, size: number): number;
    /**读取指定大小有符号整数 */
    readInt(offset: number, size: number): number;
    readFloat(offset: number): number;
    readDouble(offset: number): number;
    /**写入指定大小无符号整数 */
    writeUInt(offset: number, size: number, value: number): void;
    /**写入指定大小有符号整数 */
    writeInt(offset: number, size: number, value: number): void;
    writeFloat(offset: number, value: number): void;
    writeDouble(offset: number, value: number): void;
    readUTF8(offset: number, maxBytes?: number): string;
    writeUTF8(offset: number, str: string, addNull?: boolean): void;
    readUTF16(offset: number, length?: number): string;
    writeUTF16(offset: number, str: string, addNull?: boolean): void;
    /** 手动释放缓冲区 */
    close(): void;
    size : number;
  }

  const Buffer: {
    create(size: number): NexusBuffer;
    prototype: NexusBuffer;
  };

  const Gpio: {
    set(pin: number, val: boolean): void;
    read(pin: number): boolean;
    readAnalog(pin: number): number;
    readAnalogRaw(pin: number): number;
    pwmChannels: PWM[];
  };

  interface PWM {
    channel: number;
    frequency: number;
    resolution: number;
    attach(pin: number): void;
    setDuty(duty: number): void;
  }

  const PWM: { prototype: PWM };

  const WiFi: {
    softAP(ssid: string, password?: string): boolean;
    connect(ssid: string, password?: string): boolean;
    isConnected(): boolean;
    localIP(): string;
    SSID(): string;
    RSSI(): number;
    macAddress(): string;
    setMode(mode: string): void;
  };

  interface SocketObject {
    send(buffer: any, offset: number, length: number): void;
    recv(buffer: any, offset: number, length: number): number;
    recvSize(buffer: any, offset: number, length: number): boolean;
    isConnected(): boolean;
    close(): boolean;
    setTimeout(timeout: number): boolean;
  }

  const Socket: {
    connectTCP(ip: string, port: number): SocketObject;
  };

  interface NexusHttpResponse {
    readonly ok: boolean;
    readonly status: number;
    readonly statusText: string;
    readonly url: string;
    text(): string;
    buffer(): NexusBuffer;
  }

  const Http: {
    fetch(url: string, options?: any): NexusHttpResponse;
    createServer(port: number): NexusHttpServer;
  };

  interface NexusHttpServer {
    begin() : void;
    mapGet(url : string,process : function(object));
    mapPost(url : string,process : function(object));
  }

  function runTask(entry: Function): any;
  function mutexLock(obj: object): void;
  function mutexUnlock(obj: object): void;
  function println(msg: string): void;
  function gc(): void;
  function delay(ms: number): void;

  // I2C接口定义
  const I2C : {
    /** 初始化I2C总线 */
    init(sdaPin: number, sclPin: number, freq: number): I2CInstance;
  }

  interface I2CInstance {
    /** 内部实例ID（只读） */
    readonly _id: number;

    /** 内部端口号（只读） */
    readonly _port: number;

    /** SDA引脚号（只读） */
    readonly sda: number;

    /** SCL引脚号（只读） */
    readonly scl: number;

    /** 时钟频率（只读） */
    readonly freq: number;

    /**
     * 向I2C设备写入数据
     * @param addr 设备地址（7位地址）
     * @param data 要写入的数据，可以是：
     *             - 单个字节的数字
     *             - NexusBuffer对象
     * @returns 操作是否成功
     * @throws 如果参数无效或I2C实例未初始化
     */
    write(addr: number, data: number | NexusBuffer): boolean;

    /**
     * 从I2C设备读取数据
     * @param buf 用于存储读取数据的NexusBuffer对象
     * @param addr 设备地址（7位地址）
     * @param length 要读取的字节数（1-1024）
     * @returns 操作是否成功
     * @throws 如果参数无效、I2C实例未初始化或Buffer大小不足
     */
    read(buf: NexusBuffer, addr: number, length: number): boolean;

    /**
     * 向I2C设备的寄存器写入数据
     * @param addr 设备地址（7位地址）
     * @param reg 寄存器地址
     * @param data 要写入的数据，可以是：
     *             - 单个字节的数字
     *             - NexusBuffer对象
     * @returns 操作是否成功
     * @throws 如果参数无效或I2C实例未初始化
     */
    writeReg(addr: number, reg: number, data: number | NexusBuffer): boolean;

    /**
     * 从I2C设备的寄存器读取数据
     * @param addr 设备地址（7位地址）
     * @param reg 寄存器地址
     * @param length 要读取的字节数（1-1024）
     * @returns 包含读取数据的数组，每个元素为0-255的数字
     *          如果读取失败返回false
     * @throws 如果参数无效、I2C实例未初始化或读取长度超出范围
     */
    readReg(addr: number, reg: number, length: number, buf: NexusBuffer): boolean;

    /**
     * 扫描I2C总线上的设备
     * @returns 包含所有发现的I2C设备地址的数组（0x08-0x77范围）
     * @throws 如果I2C实例未初始化
     */
    scan(): number[];

    /**
     * 关闭I2C实例并释放资源
     * @returns 操作是否成功
     */
    close(): boolean;
  }

  const SPI : {
    /** SPI 模式 0: CPOL=0, CPHA=0 */
    readonly MODE_0: number;
    /** SPI 模式 1: CPOL=0, CPHA=1 */
    readonly MODE_1: number;
    /** SPI 模式 2: CPOL=1, CPHA=0 */
    readonly MODE_2: number;
    /** SPI 模式 3: CPOL=1, CPHA=1 */
    readonly MODE_3: number;
    /** 高位在前传输顺序 */
    readonly MSBFIRST: number;
    /** 低位在前传输顺序 */
    readonly LSBFIRST: number;
    /** HSPI 总线 (SPI2_HOST) */
    readonly HSPI: number;
    /** VSPI 总线 (SPI3_HOST) */
    readonly VSPI: number;

    /**
     * 初始化 SPI 总线
     * @param bus_num 总线编号: 1 (HSPI) 或 2 (VSPI)
     * @param cs_pin 片选引脚号
     * @param clock_speed 时钟频率 (100KHz - 40MHz)
     * @param mode SPI 模式 (MODE_0, MODE_1, MODE_2, MODE_3)
     * @param bit_order 传输顺序 (MSBFIRST 或 LSBFIRST)
     * @param data_bits 数据位数 (8, 16 或 32)
     * @returns 返回 SPI 实例对象
     * @throws 如果参数无效或初始化失败
     */
    init(
      bus_num: 1 | 2,
      cs_pin: number,
      clock_speed: number,
      mode: number,
      bit_order: number,
      data_bits: 8 | 16 | 32
    ): SPIInstance;
  }

  /**
   * SPI 实例接口
   */
  interface SPIInstance {
    /** 内部实例ID（只读） */
    readonly _id: number;
    /** 总线编号（只读） */
    readonly bus: number;
    /** 片选引脚（只读） */
    readonly cs: number;
    /** 时钟频率（只读） */
    readonly clock: number;
    /** SPI 模式（只读） */
    readonly mode: number;
    /** 传输顺序（只读） */
    readonly bit_order: number;
    /** 数据位数（只读） */
    readonly data_bits: number;

    /**
     * 析构函数（内部使用）
     * @returns 操作是否成功
     */
    finalize(): boolean;

    /**
     * SPI 全双工传输
     * @param tx_buffer 发送数据的 NexusBuffer
     * @param rx_buffer 接收数据的 NexusBuffer
     * @returns 传输是否成功
     * @throws 如果参数无效、SPI实例未初始化
     */
    transfer(tx_buffer: NexusBuffer, rx_buffer: NexusBuffer): boolean;

    /**
     * 发送数据到 SPI 设备
     * @param data 要发送的数据，可以是：
     *             - 单个字节的数字
     *             - NexusBuffer 对象
     * @returns 发送是否成功
     * @throws 如果参数无效、SPI实例未初始化
     */
    write(data: number | NexusBuffer): boolean;

    /**
     * 从 SPI 设备读取数据
     * @param buf 用于存储读取数据的 NexusBuffer
     * @param length 要读取的字节数 (1-4096)
     * @returns 读取是否成功
     * @throws 如果参数无效、Buffer大小不足、SPI实例未初始化
     */
    read(buf: NexusBuffer, length: number): boolean;

    /**
     * 传输 16 位数据
     * @param data 要发送的 16 位数据
     * @returns 接收到的 16 位数据
     * @throws 如果参数无效、SPI实例未初始化
     */
    transfer16(data: number): number;

    /**
     * 传输 32 位数据
     * @param data 要发送的 32 位数据
     * @returns 接收到的 32 位数据
     * @throws 如果参数无效、SPI实例未初始化
     */
    transfer32(data: number): number;

    /**
     * 手动设置片选引脚状态
     * @param state 片选状态: true 为低电平选中, false 为高电平取消选中
     * @returns 设置是否成功
     * @throws 如果参数无效或SPI实例未初始化
     */
    setCS(state: boolean): boolean;

    /**
     * 获取当前 SPI 配置
     * @returns 包含配置信息的对象
     * @throws 如果SPI实例未初始化
     */
    getConfig(): {
      bus: number;
      cs_pin: number;
      clock_speed: number;
      mode: number;
      bit_order: number;
      data_bits: number;
    };

    /**
     * 关闭 SPI 实例并释放资源
     * @returns 操作是否成功
     */
    close(): boolean;
  }

  const FS: {
    // 文件系统操作
    format(): boolean;
    mount(): boolean;
    unmount(): boolean;

    // 文件操作
    open(path: string, mode: number): NexusFile | false;
    remove(path: string): boolean;
    rename(oldPath: string, newPath: string): boolean;
    exists(path: string): boolean;
    stat(path: string): FileInfo | null;
    listDir(path: string): FileInfo[];

    // 目录操作
    mkdir(path: string): boolean;
    rmdir(path: string): boolean;
    removeDir(path: string): boolean;
    isDirectory(path: string): boolean;

    // 空间信息
    totalBytes(): number;
    usedBytes(): number;

    // 常量
    readonly FILE_READ: number;
    readonly FILE_WRITE: number;
    readonly FILE_APPEND: number;
  };

  interface NexusFile {
    // 文件操作
    close(): boolean;
    read(buffer: NexusBuffer, offset: number, length: number): number;
    write(offset: number, length: number, data: NexusBuffer | number): number;
    size(): number;
    position(): number;
    seek(offset: number, whence: number): boolean;
    flush(): boolean;

    // 属性
    readonly _id: number;
    readonly path: string;
    readonly mode: number;
  }

  interface FileInfo {
    name: string;
    size: number;
    isDirectory: boolean;
    isFile: boolean;
  }

  const System: {
  // 系统控制
  reboot(): never;
  restart(): never;
  deepSleep(timeUs?: number): never;
  lightSleep(timeUs?: number): void;
  
  // 系统信息
  getBootReason(): number;
  getWakeupReason(): number;
  getChipInfo(): ChipInfo;
  getMemoryInfo(): MemoryInfo;
  getUptime(): number;
  getUptimeMicros(): number;
  
  // 延时控制
  delay(ms: number): void;
  delayMicroseconds(us: number): void;
  
  // 看门狗
  watchdogEnable(enable: boolean): boolean;
  feedWatchdog(): void;

  gc() : void;
  
  // 启动原因常量
  readonly BOOT_REASON_UNKNOWN: number;
  readonly BOOT_REASON_POWERON: number;
  readonly BOOT_REASON_RESET: number;
  readonly BOOT_REASON_EXCEPTION: number;
  readonly BOOT_REASON_WDT: number;
  readonly BOOT_REASON_DEEPSLEEP: number;
  readonly BOOT_REASON_BROWNOUT: number;
  readonly BOOT_REASON_SDIO: number;
  
  // 唤醒原因常量
  readonly WAKEUP_REASON_UNDEFINED: number;
  readonly WAKEUP_REASON_EXT0: number;
  readonly WAKEUP_REASON_EXT1: number;
  readonly WAKEUP_REASON_TIMER: number;
  readonly WAKEUP_REASON_TOUCHPAD: number;
  readonly WAKEUP_REASON_ULP: number;
  readonly WAKEUP_REASON_GPIO: number;
  readonly WAKEUP_REASON_UART: number;
};

interface ChipInfo {
  model: number;
  cores: number;
  revision: number;
  id: number;
}

interface MemoryInfo {
  heapSize: number;
  freeHeap: number;
  minFreeHeap: number;
  maxAllocHeap: number;
  psramSize?: number;
  freePsram?: number;
  minFreePsram?: number;
  maxAllocPsram?: number;
}

}

export { };
