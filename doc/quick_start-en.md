# NexusEJS Quick Guide  

## Build and Deploy  

### Write and Compile Scripts  

1. Write your JavaScript script (familiar JS developers can skip to the syntax examples below for a quick start)  
2. Run the `nejsc` compiler command:  
   ```bash
   nejsc your_app.js
   ```  
   This will generate `your_app.nejs` and the map file `your_app.nejs.map` in the directory.  

### Compile Firmware and Deploy  

1. Select the VM corresponding to your MCU version, compile the PlatformIO project, and prepare the SPIFFS file system.  
2. Rename the `.nejs` file generated by the NexusEJS Compiler (nejsc) to `entry.nejs` and flash it into the file system.  
3. Flash the firmware and file system, then restart the MCU.  

### Debugging  

1. **Basic Stack Trace Line Number Retrieval**  
   Copy the `stackTrace` field from the exception object, then use the `offset2line` tool with the command:  
   ```bash
   offset2line your_app.nejs.map
   ```  
   Load the map file, and paste the stack trace information as prompted to get the source code line numbers.  

2. **Using the nejsdbg Debugger**  
   Start the nejsdbg debugger with the following command:  
   ```bash
   nejsdbg <mode> <addr>
   ```  
   Example:  
   ```bash
   nejsdbg serial COM3
   ```  

   You will then see the following interface:  
   ```bash
   Connected COM3
   Restart device to trig the default breakpoint.
   ====BreakPoint====
   Stack trace:
     at main_entry() line:1
   Scopes:
     {start:0, length:325, ep:325, attr:0}
     {start:6, length:319, ep:0, attr:0}
   NexusEJS.Debugger>>
   ```  

   If the breakpoint is not triggered automatically, press the RST button on the device to restart it. The VM with debugging enabled will automatically trigger a breakpoint at the first line of the `main_entry` function.  

### Try Basic Commands  

Set a breakpoint at line 30 of `entry.js` (ensure the `entry.nejs.map` mapping file is in the same directory, otherwise it will fail):  
```bash
NexusEJS.Debugger>>break add entry.js:30
done
NexusEJS.Debugger>>break list
entry.js:30
entry.js:1
done
NexusEJS.Debugger>>break remove entry.js:30
done
NexusEJS.Debugger>>resume
done
NexusEJS.Debugger>>
```  

Manually pause VM execution:  
```bash
NexusEJS.Debugger>>stw
at main_entry()  line:30

====BreakPoint====
Stack trace:
  at main_entry()  line:30
Variables:
  server = {"mapPost":<func>,"_id":1,"begin":<func>,"port":80,"_cb":[<clos_fn>],"finalize":<func>,"mapGet":<func>}
  cnt = 0
  obj = {"inc":<clos_fn>,"value":0}
Scopes:
  {start:0, length:325, ep:325, attr:0}
  {start:6, length:319, ep:319, attr:0}
  {start:275, length:50, ep:20, attr:1}
NexusEJS.Debugger>>
```  

For more debugger examples, refer to the NexusEJS-Debugger documentation.  

---  

NexusEJS syntax and runtime are optimized for embedded systems, so memory management and coding style differ from web JavaScript.  

## Variable Definition  

NexusEJS compiler disables `var`. You must use `let` to define variables. `const` will be supported in the future.  

## Object-Oriented Programming  

NexusEJS does not support the `new` and `class` keywords. Instead, you need to use the factory pattern (Object Factory) to create objects:  
```javascript
global.Human = {
    create(name, age) {
        return {
            name: name,
            age: age,
            getInfo() {
                return "My name is " + this.name + " and my age is " + this.age;
            }
        }
    }
}

let man = Human.create("bob", 25);
println(man.getInfo());
```  

Here, `global` represents the global variable space, similar to `window` in browsers. Using the factory pattern avoids the memory overhead of prototype chains, as MCUs have very limited memory (KB-level).  

## Closures  

NexusEJS supports closures, which are triggered in the following cases:  
- Passed as arguments  
- Returned as values  
- Assigned to variables  

**Use closures judiciously to avoid unnecessary memory usage. Closures are only triggered when lambda expressions or function references access variables outside their scope.**  

**Closures capture by value: `number` and `boolean` types are copied, and modifications do not affect the original variable.**  

Example:  
```javascript
function getCounter() {
    let cnt = 0;
    let obj = { value: 0 };
    return () => {
        cnt++;
        obj.value++;
    }
}

let inc = getCounter();
inc();
```  

## Comparison Operators  

NexusEJS runtime behavior defaults to something like traditional JavaScript's `'use strict'`, but stricter.  

NexusEJS does not allow mixing `"123"` and `123`. The `==` operator behaves the same as the standard JavaScript `===` operator. You must convert to the same type using `Number.parseInt()` or `Number.parseFloat()`.  

Similarly, array indices cannot be strings, avoiding undefined behavior caused by implicit conversions.  

## Memory Management  

NexusEJS uses automatic garbage collection (GC), which triggers when the remaining memory percentage reaches a threshold. This can be controlled via the `LESS_MEMORY_TRIG_COLLECT` macro in `GC.h`.  

You can also manually trigger it via the native binding function:  
```javascript
gc();
```  

Triggering GC causes a "Stop The World" pause. Use GC judiciously. It is recommended to manually call GC to reclaim garbage before executing high real-time tasks to avoid unexpected pauses.  

### READY TO FINALIZE Mechanism  

The READY TO FINALIZE mechanism allows objects to control their lifecycle and release bound native resources by implementing a `finalize() : boolean` method.  

When GC is about to reclaim an object, the `finalize()` method is called. If it returns `false`, GC will not reclaim the object or any of its child references. If it returns `true`, the `finalize()` member method is removed by GC, and the object will be reclaimed during the next GC cycle.  

**Warning: Do not directly call `obj.finalize()`. This method is only for GC callbacks; otherwise, undefined behavior may occur.**  

## Multitasking  

NexusEJS’s task model differs from standard JavaScript. NexusEJS removes the event loop and replaces it with real threads based on the platform OS. Therefore, you don’t need to worry about native methods blocking other tasks, but be cautious with concurrent resource access.  

The `async` and `await` keywords have been removed. However, you can create tasks using the `runTask(func, param) : TaskObject` method, which returns a `TaskObject`. You can use:  
- `.id` to get the task ID  
- `.isRunning()` to check if the task is running  
- `.getResult()` to get the task’s return value (returns `null` if the task is still running)  

For concurrent resource access, use mutex locks or critical sections. NexusEJS provides the `lock(obj) { ... }` syntactic sugar. Example:  
```javascript
let sharedObject = { ... };

// Access in another task
lock(sharedObject) {
    // Operations are safe here
}
```  

## Buffer Type  

The `Buffer` type is a native buffer binding class specifically designed for NexusEJS, allowing JavaScript scripts to create native buffers of a specified size.  

Usage example:  
```javascript
let size = 32;
let buf = Buffer.create(size);
let offset = 0;
// writeUInt(offset, size, value)
buf.writeUInt(offset, 4, 123); // The size range is 1–8. A 64-bit integer may overflow.
// readUInt(offset, size)
let read = buf.readUInt(offset, 4);

// Write a string
buf.writeUTF16(offset, "hello");

buf = null; // Disconnect the reference
gc(); // Call GC to free the buffer
```
