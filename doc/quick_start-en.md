# NexusEJS Quick Guide  

## Build and Deploy  

### Write and Compile Scripts  

1. Write your JavaScript script.  
2. Run the `nejsc` compiler command:  
```bash  
nejsc your_app.js  
```  
   This will generate `your_app.nejs` and a mapping file `your_app.nejs.map` in the current directory.  

### Compile Firmware and Deploy  

1. Select the VM corresponding to your MCU version, compile the PlatformIO project, and prepare the SPIFFS file system.  
2. Rename the `.nejs` file generated by the NexusEJS Compiler (`nejsc`) to `entry.nejs` and flash it into the file system.  
3. Flash the firmware and file system, then restart the MCU.  

### Debugging  

Copy the `stackTrace` field from the exception object, then use the `offset2line` tool with the command:  

```bash  
offset2line your_app.nejs.map  
```  
Load the map file, and paste the stack trace as prompted to get the corresponding source code line numbers.  

---  

NexusEJS syntax and runtime are optimized for embedded systems, so memory management and coding style differ from web JavaScript.  

## Variable Definition  

NexusEJS disables `var`; you must use `let` to define variables. `const` will be supported in the future.  

## Object-Oriented Programming  

NexusEJS does not support the `new` or `class` keywords. Instead, you should use the **Object Factory** pattern to create objects:  

```javascript  
global.Human = {  
    create(name, age) {  
        return {  
            name: name,  
            age: age,  
            getInfo() {  
                return "My name is " + this.name + " and my age is " + this.age;  
            }  
        };  
    }  
};  

let man = Human.create("bob", 25);  
println(man.getInfo());  
```  

Here, `global` represents the global variable space, similar to `window` in browsers. Using the factory pattern avoids the memory overhead of prototype chains, which is critical for MCUs with KB-level memory.  

## Closures  

NexusEJS currently does **not** support closures, primarily for memory efficiency. Based on feedback, closures may be supported in the future. It is generally recommended to explicitly pass required information to avoid memory leaks caused by extended object lifetimes.  

Example:  

```javascript  
function getCounter() {  
    let cnt = 0;  
    return function inc() {  
        cnt++;  // Error: can't find symbol: cnt  
    };  
}  

function getCounter() {  
    let cnt = 0;  
    return {  
        innerCnt: cnt,  
        inc() {  
            this.innerCnt++; // Works  
        }  
    };  
}  
```  

## Comparison Operators  

NexusEJS runtime behavior is similar to traditional JavaScript's `'use strict'` but stricter.  

NexusEJS does **not** allow mixing `"123"` and `123`. The `==` operator behaves identically to the standard JavaScript `===` operator. Values must be converted to the same type using `Number.parse()`.  

Similarly, array indices **cannot** be strings, avoiding undefined behavior caused by implicit conversions.  

## Memory Management  

NexusEJS uses automatic garbage collection (GC), triggered when the remaining memory percentage reaches a threshold. This threshold can be controlled via the macro `LESS_MEMORY_TRIG_COLLECT` in `GC.h`.  

You can also manually trigger GC using the native binding function:  
```javascript  
gc();  
```  

GC triggers a **Stop-The-World** pause, so its usage should be carefully considered. It is recommended to manually invoke GC before high-real-time tasks to avoid unexpected pauses.  

### READY TO FINALIZE Mechanism  

The **READY TO FINALIZE** mechanism allows objects to control their own lifecycle and release bound native resources by implementing a `finalize(): boolean` method.  

When GC is about to reclaim an object, the `finalize()` method is called. If it returns `false`, GC will **not** reclaim the object or its child references. If it returns `true`, the `finalize()` method is removed by GC, and the object will be reclaimed during the next GC cycle.  

**Warning: Do NOT call `obj.finalize()` directly. This method is only for GC callbacks; otherwise, undefined behavior may occur.**  

## Multitasking  

NexusEJS uses a different task model than standard JavaScript. It replaces the event loop with **real threads** based on the platform OS. Therefore, you don’t need to worry about native methods blocking other tasks, but concurrent resource access must be handled carefully.  

The `async` and `await` keywords are removed. However, tasks can be created using the `runTask(func, param): TaskObject` method, which returns a `TaskObject` with the following properties:  
- `.id`: Get the task ID.  
- `.isRunning()`: Check if the task is running.  
- `.getResult()`: Get the task’s return value (returns `null` if the task is still running).  

For concurrent resource access, use mutex locks or critical sections. NexusEJS provides the `lock(obj) { ... }` syntax sugar:  

```javascript  
let sharedObject = { ... };  

// Access in another task  
lock(sharedObject) {  
    // Safe operations here  
}  
```  

## Buffer Type  

The `Buffer` type is a native buffer binding class specifically designed for NexusEJS, allowing JavaScript scripts to create native buffers of a specified size.  

Usage example:  

```javascript  
let size = 32;  
let buf = Buffer.create(size);  
let offset = 0;  

// writeUInt(offset, size, value)  
buf.writeUInt(offset, 4, 123); // Size range: 1–8. A 64-bit integer may overflow.  

// readUInt(offset, size)  
let read = buf.readUInt(offset, 4);  

// Write string  
buf.writeUTF16(offset, "hello");  

buf = null; // Disconnect the reference  
gc(); // Call GC to free the buffer  
```
