# NexusEJS Quick Guide

## Build and Deployment

### Write and Compile Scripts

1. Write your JavaScript script.
2. Run the nejsc compiler command: `nejsc your_app.js`. This will generate `your_app.nejs` and the map file `your_app.nejs.map` in the directory.

### Compile Firmware and Deploy

1. Select the VM corresponding to your MCU version, compile the PlatformIO project, and prepare the SPIFFS filesystem.
2. Rename the `.nejs` file generated by the NexusEJS-Compiler (nejsc) to `entry.nejs` and flash it into the filesystem.
3. Flash the firmware and filesystem, then restart the MCU.

### Debugging

Copy the `stackTrace` field from the exception object. Use the `offset2line` tool with the command: `offset2line your_app.nejs.map` to load the map file. Then, paste the stack trace information as prompted to obtain the source code line numbers.

---

NexusEJS syntax and runtime are optimized for embedded systems, so memory management and coding style differ from web JavaScript.

## Variable Definition

NexusEJS compiler disables `var`. You must use `let` to define variables. `const` will be supported in the future.

## Object-Oriented Programming

NexusEJS does not support the `new` and `class` keywords. Therefore, you need to use the Factory Pattern (Object Factory) to create objects.

```javascript
global.Human = {
    create(name, age) {
        return {
            name: name,
            age: age,
            getInfo() {
                return "My name is " + this.name + " and my age is " + this.age;
            }
        }
    }
}

let man = Human.create("bob", 25);
println(man.getInfo());
```

Here, `global` represents the global variable space, similar to `window` in browsers. Using the factory pattern avoids the memory overhead of prototype chains, which is crucial given the MCU's limited KB-level memory.

## Closures

NexusEJS supports closures, which are triggered in the following cases:
- When passed as a parameter
- When returned as a value
- When assigned

**Use closures judiciously to avoid unnecessary memory consumption. Closures are only triggered when a lambda expression or function references variables outside its scope.**

**Closures capture by value. Number and boolean types are copied, and modifications do not affect the original variables.**

Example:

```javascript
function getCounter(){
    let cnt = 0;
    return ()=>{
        cnt++; 
    }
}

let inc = getCounter();
inc();
```

## Comparison Operators

NexusEJS runtime behavior defaults to something like traditional JavaScript's 'use strict', but is stricter.

NexusEJS does not support mixing `"123"` and `123`. The `==` operator behaves identically to the standard JavaScript `===` operator. You must convert to the same type using `Number.parseInt()` or `Number.parseFloat()`.

Similarly, string indices are not allowed for arrays, to avoid undefined behavior caused by implicit conversions.

## Memory Management

NexusEJS uses automatic garbage collection (GC). GC is triggered automatically when the remaining memory percentage reaches a threshold, controlled by the macro `LESS_MEMORY_TRIG_COLLECT` in GC.h.

You can also manually trigger it via the native binding function:

```javascript
gc();
```

GC triggers a "Stop The World" pause. You must weigh the use of GC carefully. It is recommended to manually call GC to reclaim garbage before executing high-real-time tasks to avoid unexpected pauses.

### READY TO FINALIZE Mechanism

The READY TO FINALIZE mechanism allows objects to control their own lifecycle and release bound native resources by implementing the `finalize(): boolean` method.

When GC is about to reclaim an object, the `finalize()` method is called by GC. If it returns `false`, GC will not reclaim this object or any of its child references. If it returns `true`, the `finalize()` member method is removed by GC, and the object will be reclaimed on the next GC cycle.

**Warning: Do not call `obj.finalize()` directly. This method is only for GC callbacks; otherwise, undefined behavior may occur.**

## Multitasking

NexusEJS's task model differs from standard JavaScript. NexusEJS removes the event loop, replacing it with real threads based on the platform OS. Therefore, you don't need to worry about native methods blocking other tasks, but you must be cautious with concurrent resource access.

The `async` and `await` keywords have been removed. However, you can create tasks using the `runTask(func, param): TaskObject` method, which returns a `TaskObject`. You can use:

- `.id` to get the task ID.
- `.isRunning()` to check if the task is running.
- `.getResult()` to get the task's return value (returns `null` if the task is still running).

For concurrent resource access, you need to use mutex locks (critical sections). NexusEJS provides the `lock(obj) { ... }` syntax sugar. Example:

```javascript
let sharedObject = { ... };

// Access in another task
lock(sharedObject) {
    // Operations are safe here
}
```

## Buffer Type

The `Buffer` type is a native buffer binding class specifically designed for NexusEJS, allowing JavaScript scripts to create native buffers of a specified size.

Usage example:

```javascript
let size = 32;
let buf = Buffer.create(size);
let offset = 0;
// writeUInt(offset, size, value)
buf.writeUInt(offset, 4, 123); // Size range: 1-8. A 64-bit integer may overflow.
// readUInt(offset, size);
let read = buf.readUInt(offset, 4);

// Write string
buf.writeUTF16(offset, "hello");

buf = null; // Disconnect the reference
gc(); // Call GC to free the buffer
```
